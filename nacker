#!/usr/bin/env python
'''
Nacker is a tool to circumvent 802.1x Network Access Control (NAC) on
a wired LAN.

Copyright (C) 2013  Carsten Maartmann-Moe

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

Created on Aug 29, 2013

@author: Carsten Maartmann-Moe <carsten@carmaa.com> aka ntropy
'''

from datetime import date
from caravan import arp, dhcp, icmp, tcp, platform
import getopt
import os
import sys
import socket
import netifaces
from pprint import pprint
from netaddr import IPNetwork

VERSION = '0.0.1'
URL = 'http://github.com/carmaa/nacker'
PC_MANUFACTURERS = ['Apple', 'Lenovo', 'Dell', 'Hewlett-Packard', 
                    'Acer' ,'ASUS', 'Fujitsu', 'Sony', 'Toshiba']
PRINTER_MANUFACTURERS = ['Xerox', 'Lexmark', 'Rioch', 'Canon', 'Brother']


def banner():
    '''
    Print obligatory banner
    '''
    print('Nacker - bypass 802.1x LAN NAC')
    print('v{0} (C) Carsten Maartmann-Moe {1}'.format(VERSION, date.today().strftime("%Y")))
    print('Download: {0} | Twitter: @breaknenter'.format(URL))
    print('')



def main(argv):
    encoding = sys.getdefaultencoding()
    
    banner()

    # Check if we're root
    if not platform.is_root():
        system.exit(1)
    
    # Parse args
    try:
        opts, args = getopt.getopt(argv[1:], 'h', ['help'])
    except getopt.GetoptError as err:
        print(err)
        usage(argv[0])
        sys.exit(2)
    for opt, arg in opts:
        if opt in ('-h', '--help'):
            usage(argv[0])
            sys.exit()
        else:
            assert False, 'Option not handled: ' + opt
    
    # We don't accept any other arguments
    if args:
        term.warn('Arguments {0} ignored'.format(', '.join(args)))
    
    # Main logic goes here

    # Get interfaces, ip address and netmask
    iface = platform.ip_interfaces().next()
    # ip_interfaces = []
    # for i in ifaces:
    #     try:
    #         addresses = netifaces.ifaddresses(i)
    #         if addresses[netifaces.AF_INET][0]['addr'] not in LOCALHOST_ADDR:
    #             ip_interfaces.append(i)
    #     except KeyError:
    #         pass
    #print(ip_interfaces)
    #ip = socket.gethostbyname(socket.gethostname())
    # interface = ip_interfaces[0]
    # addresses = netifaces.ifaddresses(interface)[netifaces.AF_INET][0]
    # subnet = IPNetwork(addresses['addr'] + '/' + addresses['netmask'])
    print('Using interface {0} with address {1} and netmask {2}:'.format(
        iface.name, iface.ip, iface.subnet.netmask))

    # Do an ARP ping sweep against the subnet
    hosts = arp.pingsweep(iface.subnet)

    # Check if we can ping the hosts, try until first answer or exhausted
    for host in hosts:
        if icmp.ping(host[0]):
            break

    # Sort the MAC addresses based on organization, laptops anw workstations
    #pprint(hosts)
    hosts.sort(key = lambda host: host[1].oui.registration().org in PC_MANUFACTURERS)
    #pprint(hosts)

    # Portscan the first host to see if packets are dropped (baseline)
    baseline = tcp.synscan(host[0])
    print('Found {0} open ports:'.format(len(baseline)))
    for item in baseline:
        print(item)

    # For each MAC address, grab it and ask for an IP
    for ip, mac in hosts:
        dhcp.discover(mac)
        # Check IP against IP originally associated with MAC - if they are not
        # equal, we're likely authenticated to the switch


def usage(execname):
    print(
'''Nacker is a tool to bypass 802.1x Network Access Control (NAC) on a wired LAN.

Usage: ''' + os.path.basename(execname) + ''' [OPTIONS]

Options:
    -h, --help:           Displays this message.''')


if __name__ == '__main__':
    main(sys.argv)
